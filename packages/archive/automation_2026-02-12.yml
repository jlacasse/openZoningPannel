# Initialize zone states on boot to avoid "unknown" states in Home Assistant
esphome:
  on_boot:
    - priority: -100  # Run after all components are initialized
      then:
        - lambda: |-
            // Zone state constant definitions
            #ifndef ZONE_OFF
            #define ZONE_OFF 0
            #define ZONE_FAN_ONLY 1
            #define ZONE_COOLING_STAGE1 2
            #define ZONE_COOLING_STAGE2 3
            #define ZONE_HEATING_STAGE1 4
            #define ZONE_HEATING_STAGE2 5
            #define ZONE_PURGE 6
            #define ZONE_WAIT 7
            #define ZONE_ERROR 99
            #endif

            // Force initial state calculation and text sensor updates
            id(z1_state) = ZONE_OFF;
            id(z1_state_text).update();
            id(z2_state) = ZONE_OFF;
            id(z2_state_text).update();
            id(z3_state) = ZONE_OFF;
            id(z3_state_text).update();
            id(z4_state) = ZONE_OFF;
            id(z4_state_text).update();
            id(z5_state) = ZONE_OFF;
            id(z5_state_text).update();
            id(z6_state) = ZONE_OFF;
            id(z6_state_text).update();

            // Initialize damper states (all open on boot)
            id(z1_damper_state) = 1;
            id(z2_damper_state) = 1;
            id(z3_damper_state) = 1;
            id(z4_damper_state) = 1;
            id(z5_damper_state) = 1;
            id(z6_damper_state) = 1;
        
        # Set all dampers to open position using scripts for consistency
        - script.execute: z1_damper_open
        - script.execute: z2_damper_open
        - script.execute: z3_damper_open
        - script.execute: z4_damper_open
        - script.execute: z5_damper_open
        - script.execute: z6_damper_open

# Damper control scripts - provide 250ms delay for motor release
script:
  - id: z1_damper_open
    mode: single
    then:
      - switch.turn_off: Z1_damper_close
      - switch.turn_off: Z1_damper_open
      - delay: 250ms
      - switch.turn_on: Z1_damper_open
      
  - id: z1_damper_close
    mode: single
    then:
      - switch.turn_off: Z1_damper_open
      - switch.turn_off: Z1_damper_close
      - delay: 250ms
      - switch.turn_on: Z1_damper_close
      
  - id: z2_damper_open
    mode: single
    then:
      - switch.turn_off: Z2_damper_close
      - switch.turn_off: Z2_damper_open
      - delay: 250ms
      - switch.turn_on: Z2_damper_open
      
  - id: z2_damper_close
    mode: single
    then:
      - switch.turn_off: Z2_damper_open
      - switch.turn_off: Z2_damper_close
      - delay: 250ms
      - switch.turn_on: Z2_damper_close
      
  - id: z3_damper_open
    mode: single
    then:
      - switch.turn_off: Z3_damper_close
      - switch.turn_off: Z3_damper_open
      - delay: 250ms
      - switch.turn_on: Z3_damper_open
      
  - id: z3_damper_close
    mode: single
    then:
      - switch.turn_off: Z3_damper_open
      - switch.turn_off: Z3_damper_close
      - delay: 250ms
      - switch.turn_on: Z3_damper_close
      
  - id: z4_damper_open
    mode: single
    then:
      - switch.turn_off: Z4_damper_close
      - switch.turn_off: Z4_damper_open
      - delay: 250ms
      - switch.turn_on: Z4_damper_open
      
  - id: z4_damper_close
    mode: single
    then:
      - switch.turn_off: Z4_damper_open
      - switch.turn_off: Z4_damper_close
      - delay: 250ms
      - switch.turn_on: Z4_damper_close
      
  - id: z5_damper_open
    mode: single
    then:
      - switch.turn_off: Z5_damper_close
      - switch.turn_off: Z5_damper_open
      - delay: 250ms
      - switch.turn_on: Z5_damper_open
      
  - id: z5_damper_close
    mode: single
    then:
      - switch.turn_off: Z5_damper_open
      - switch.turn_off: Z5_damper_close
      - delay: 250ms
      - switch.turn_on: Z5_damper_close
      
  - id: z6_damper_open
    mode: single
    then:
      - switch.turn_off: Z6_damper_close
      - switch.turn_off: Z6_damper_open
      - delay: 250ms
      - switch.turn_on: Z6_damper_open
      
  - id: z6_damper_close
    mode: single
    then:
      - switch.turn_off: Z6_damper_open
      - switch.turn_off: Z6_damper_close
      - delay: 250ms
      - switch.turn_on: Z6_damper_close

interval:
  - interval: 10s
    then:
      - lambda: |-
          // Zone state constant definitions
          #ifndef ZONE_OFF
          #define ZONE_OFF 0
          #define ZONE_FAN_ONLY 1
          #define ZONE_COOLING_STAGE1 2
          #define ZONE_COOLING_STAGE2 3
          #define ZONE_HEATING_STAGE1 4
          #define ZONE_HEATING_STAGE2 5
          #define ZONE_PURGE 6
          #define ZONE_WAIT 7
          #define ZONE_ERROR 99
          #endif

          // Define logging tag
          static const char* TAG = "ZoneError";

          // Reset error flag at the beginning of each cycle
          id(zone_error_flag) = false;
          
          // ============= MACRO DEFINITIONS FOR ZONE CONTROL =============
          // These macros use token pasting (##) to generate zone-specific code
          // Usage: CALC_ZONE_STATE(1) expands to zone 1's state calculation code
          
          // MACRO 1: Calculate zone state based on thermostat inputs
          // Detects errors (Y1/Y2 without G), determines state priority (Y2 > Y1)
          #define CALC_ZONE_STATE(N) \
            int z##N##_state_new = ZONE_OFF; \
            \
            if ((id(Z##N##_Y1).state || id(Z##N##_Y2).state) && !id(Z##N##_G).state) { \
              id(z##N##_error_count)++; \
              if (id(z##N##_error_count) == 1) { \
                ESP_LOGW(TAG, "Zone " #N " error detected (count: 1/2) - Y1:%d Y2:%d G:%d", id(Z##N##_Y1).state, id(Z##N##_Y2).state, id(Z##N##_G).state); \
              } \
              if (id(z##N##_error_count) >= 2) { \
                ESP_LOGE(TAG, "Zone " #N " ERROR CONFIRMED (count: 2/2) - Y1:%d Y2:%d G:%d", id(Z##N##_Y1).state, id(Z##N##_Y2).state, id(Z##N##_G).state); \
                z##N##_state_new = ZONE_ERROR; \
                id(zone_error_flag) = true; \
              } \
            } else { \
              if (id(z##N##_error_count) > 0) { \
                ESP_LOGI(TAG, "Zone " #N " error cleared (was at count: %d)", id(z##N##_error_count)); \
                id(z##N##_error_count) = 0; \
              } \
            } \
            \
            if (z##N##_state_new != ZONE_ERROR && id(Z##N##_Y2).state && id(Z##N##_G).state && id(Z##N##_OB).state) { \
              z##N##_state_new = ZONE_HEATING_STAGE2; \
            } \
            else if (z##N##_state_new != ZONE_ERROR && id(Z##N##_Y1).state && id(Z##N##_G).state && id(Z##N##_OB).state) { \
              z##N##_state_new = ZONE_HEATING_STAGE1; \
            } \
            else if (z##N##_state_new != ZONE_ERROR && id(Z##N##_Y2).state && id(Z##N##_G).state && !id(Z##N##_OB).state) { \
              z##N##_state_new = ZONE_COOLING_STAGE2; \
            } \
            else if (z##N##_state_new != ZONE_ERROR && id(Z##N##_Y1).state && id(Z##N##_G).state && !id(Z##N##_OB).state) { \
              z##N##_state_new = ZONE_COOLING_STAGE1; \
            } \
            else if (z##N##_state_new != ZONE_ERROR && id(Z##N##_G).state) { \
              z##N##_state_new = ZONE_FAN_ONLY; \
            }
          
          // MACRO 2: Short cycle protection - enforces minimum cycle time
          // Prevents rapid on/off cycling that can damage HVAC equipment
          #define SHORT_CYCLE_PROTECTION(N) \
            if (id(z##N##_state) == ZONE_OFF && (z##N##_state_new == ZONE_COOLING_STAGE1 || z##N##_state_new == ZONE_COOLING_STAGE2 || z##N##_state_new == ZONE_HEATING_STAGE1 || z##N##_state_new == ZONE_HEATING_STAGE2)) { \
              id(z##N##_active_start_ms) = millis(); \
              ESP_LOGI(TAG_SCP, "Zone " #N " started active cycle at %lu ms", id(z##N##_active_start_ms)); \
            } \
            \
            if (z##N##_state_new == ZONE_ERROR) { \
              id(z##N##_active_start_ms) = 0; \
              if (id(z##N##_short_cycle_protection)) { \
                id(z##N##_short_cycle_protection) = false; \
              } \
            } \
            \
            bool z##N##_protection_changed = false; \
            if ((id(z##N##_state) == ZONE_COOLING_STAGE1 || id(z##N##_state) == ZONE_COOLING_STAGE2 || id(z##N##_state) == ZONE_HEATING_STAGE1 || id(z##N##_state) == ZONE_HEATING_STAGE2) && \
                z##N##_state_new == ZONE_OFF && z##N##_state_new != ZONE_ERROR) { \
              unsigned long elapsed = current_time - id(z##N##_active_start_ms); \
              if (elapsed < id(min_cycle_time_ms)) { \
                z##N##_state_new = id(z##N##_state); \
                if (!id(z##N##_short_cycle_protection)) { \
                  id(z##N##_short_cycle_protection) = true; \
                  z##N##_protection_changed = true; \
                } \
                ESP_LOGW(TAG_SCP, "Zone " #N " short cycle protection active - elapsed: %lu ms / required: %lu ms", elapsed, id(min_cycle_time_ms)); \
              } else { \
                if (id(z##N##_short_cycle_protection)) { \
                  id(z##N##_short_cycle_protection) = false; \
                  z##N##_protection_changed = true; \
                } \
                id(z##N##_active_start_ms) = 0; \
              } \
            } else if (z##N##_state_new != ZONE_OFF && z##N##_state_new != ZONE_ERROR) { \
              if (id(z##N##_active_start_ms) > 0) { \
                unsigned long elapsed = current_time - id(z##N##_active_start_ms); \
                bool new_protection = (elapsed < id(min_cycle_time_ms)); \
                if (id(z##N##_short_cycle_protection) != new_protection) { \
                  id(z##N##_short_cycle_protection) = new_protection; \
                  z##N##_protection_changed = true; \
                } \
              } \
            } else { \
              if (id(z##N##_short_cycle_protection)) { \
                id(z##N##_short_cycle_protection) = false; \
                z##N##_protection_changed = true; \
              } \
            }
          
          // MACRO 3: Intelligent purge management - only last zone purges
          // Prevents multiple zones from purging simultaneously
          #define PURGE_MANAGEMENT(N) \
            if ((z##N##_was_heating || z##N##_was_cooling) && !z##N##_is_heating && !z##N##_is_cooling && z##N##_state_new != ZONE_ERROR) { \
              unsigned long elapsed = current_time - id(z##N##_active_start_ms); \
              if (id(z##N##_active_start_ms) > 0 && elapsed < id(min_cycle_time_ms)) { \
                z##N##_state_new = id(z##N##_state); \
                id(z##N##_short_cycle_protection) = true; \
                ESP_LOGW(TAG_SCP, "Zone " #N " prevented from entering purge - minimum cycle time not met"); \
              } else { \
                bool other_zones_active = false; \
                if (z##N##_was_heating && heating_zones_count > 0) other_zones_active = true; \
                if (z##N##_was_cooling && cooling_zones_count > 0) other_zones_active = true; \
                \
                if (other_zones_active) { \
                  id(z##N##_purge_end_ms) = 0; \
                  z##N##_state_new = ZONE_OFF; \
                } else { \
                  id(z##N##_purge_end_ms) = now_ms + PURGE_DURATION_MS; \
                } \
              } \
            } \
            \
            if (id(z##N##_purge_end_ms) > now_ms && z##N##_state_new != ZONE_ERROR) { \
              z##N##_state_new = ZONE_PURGE; \
            } else if (id(z##N##_purge_end_ms) <= now_ms && id(z##N##_purge_end_ms) != 0) { \
              id(z##N##_purge_end_ms) = 0; \
            }
          
          // MACRO 4: Damper control - manages zone damper position
          // Controls damper open/close based on zone state
          #define DAMPER_CONTROL(N) \
            int z##N##_damper_target = 1; \
            if (z##N##_state_new == ZONE_WAIT || z##N##_state_new == ZONE_ERROR) { \
              z##N##_damper_target = 0; \
            } else if (all_zones_off) { \
              z##N##_damper_target = 1; \
            } else if (z##N##_state_new == ZONE_OFF) { \
              z##N##_damper_target = 0; \
            } else { \
              z##N##_damper_target = 1; \
            } \
            \
            if (z##N##_damper_target != id(z##N##_damper_state)) { \
              id(z##N##_damper_state) = z##N##_damper_target; \
              if (z##N##_damper_target == 1) { \
                ESP_LOGI(TAG_DAMPER, "Zone " #N " damper opening"); \
                id(z##N##_damper_open).execute(); \
              } else { \
                ESP_LOGI(TAG_DAMPER, "Zone " #N " damper closing"); \
                id(z##N##_damper_close).execute(); \
              } \
            }

          
          // ============= PASS 1: ZONE STATE CALCULATION =============
          // Calculate each zone's desired state based on thermostat inputs
          CALC_ZONE_STATE(1)
          CALC_ZONE_STATE(2)
          CALC_ZONE_STATE(3)
          CALC_ZONE_STATE(4)
          CALC_ZONE_STATE(5)
          CALC_ZONE_STATE(6)

          // ============= PASS 1.5: SHORT CYCLE PROTECTION =============
          // Track active start times and enforce minimum cycle time
          static const char* TAG_SCP = "ShortCycleProtection";
          unsigned long current_time = millis();
          
          SHORT_CYCLE_PROTECTION(1)
          SHORT_CYCLE_PROTECTION(2)
          SHORT_CYCLE_PROTECTION(3)
          SHORT_CYCLE_PROTECTION(4)
          SHORT_CYCLE_PROTECTION(5)
          SHORT_CYCLE_PROTECTION(6)

          // ============= PASS 2: INTELLIGENT MULTI-ZONE PURGE MANAGEMENT =============
          // Only the LAST zone to stop heating/cooling should purge
          // Other zones go to OFF immediately if other zones are still active
          unsigned long now_ms = millis();
          const unsigned long PURGE_DURATION_MS = 300000; // 5 minutes

          // Check current state of each zone
          bool z1_was_heating = (id(z1_state) == ZONE_HEATING_STAGE1 || id(z1_state) == ZONE_HEATING_STAGE2);
          bool z1_was_cooling = (id(z1_state) == ZONE_COOLING_STAGE1 || id(z1_state) == ZONE_COOLING_STAGE2);
          bool z1_is_heating = (z1_state_new == ZONE_HEATING_STAGE1 || z1_state_new == ZONE_HEATING_STAGE2);
          bool z1_is_cooling = (z1_state_new == ZONE_COOLING_STAGE1 || z1_state_new == ZONE_COOLING_STAGE2);
          
          bool z2_was_heating = (id(z2_state) == ZONE_HEATING_STAGE1 || id(z2_state) == ZONE_HEATING_STAGE2);
          bool z2_was_cooling = (id(z2_state) == ZONE_COOLING_STAGE1 || id(z2_state) == ZONE_COOLING_STAGE2);
          bool z2_is_heating = (z2_state_new == ZONE_HEATING_STAGE1 || z2_state_new == ZONE_HEATING_STAGE2);
          bool z2_is_cooling = (z2_state_new == ZONE_COOLING_STAGE1 || z2_state_new == ZONE_COOLING_STAGE2);
          
          bool z3_was_heating = (id(z3_state) == ZONE_HEATING_STAGE1 || id(z3_state) == ZONE_HEATING_STAGE2);
          bool z3_was_cooling = (id(z3_state) == ZONE_COOLING_STAGE1 || id(z3_state) == ZONE_COOLING_STAGE2);
          bool z3_is_heating = (z3_state_new == ZONE_HEATING_STAGE1 || z3_state_new == ZONE_HEATING_STAGE2);
          bool z3_is_cooling = (z3_state_new == ZONE_COOLING_STAGE1 || z3_state_new == ZONE_COOLING_STAGE2);
          
          bool z4_was_heating = (id(z4_state) == ZONE_HEATING_STAGE1 || id(z4_state) == ZONE_HEATING_STAGE2);
          bool z4_was_cooling = (id(z4_state) == ZONE_COOLING_STAGE1 || id(z4_state) == ZONE_COOLING_STAGE2);
          bool z4_is_heating = (z4_state_new == ZONE_HEATING_STAGE1 || z4_state_new == ZONE_HEATING_STAGE2);
          bool z4_is_cooling = (z4_state_new == ZONE_COOLING_STAGE1 || z4_state_new == ZONE_COOLING_STAGE2);
          
          bool z5_was_heating = (id(z5_state) == ZONE_HEATING_STAGE1 || id(z5_state) == ZONE_HEATING_STAGE2);
          bool z5_was_cooling = (id(z5_state) == ZONE_COOLING_STAGE1 || id(z5_state) == ZONE_COOLING_STAGE2);
          bool z5_is_heating = (z5_state_new == ZONE_HEATING_STAGE1 || z5_state_new == ZONE_HEATING_STAGE2);
          bool z5_is_cooling = (z5_state_new == ZONE_COOLING_STAGE1 || z5_state_new == ZONE_COOLING_STAGE2);
          
          bool z6_was_heating = (id(z6_state) == ZONE_HEATING_STAGE1 || id(z6_state) == ZONE_HEATING_STAGE2);
          bool z6_was_cooling = (id(z6_state) == ZONE_COOLING_STAGE1 || id(z6_state) == ZONE_COOLING_STAGE2);
          bool z6_is_heating = (z6_state_new == ZONE_HEATING_STAGE1 || z6_state_new == ZONE_HEATING_STAGE2);
          bool z6_is_cooling = (z6_state_new == ZONE_COOLING_STAGE1 || z6_state_new == ZONE_COOLING_STAGE2);

          // Count how many zones are CURRENTLY (in new state) heating or cooling
          int heating_zones_count = 0;
          int cooling_zones_count = 0;
          
          if (z1_is_heating) heating_zones_count++;
          if (z2_is_heating) heating_zones_count++;
          if (z3_is_heating) heating_zones_count++;
          if (z4_is_heating) heating_zones_count++;
          if (z5_is_heating) heating_zones_count++;
          if (z6_is_heating) heating_zones_count++;
          
          if (z1_is_cooling) cooling_zones_count++;
          if (z2_is_cooling) cooling_zones_count++;
          if (z3_is_cooling) cooling_zones_count++;
          if (z4_is_cooling) cooling_zones_count++;
          if (z5_is_cooling) cooling_zones_count++;
          if (z6_is_cooling) cooling_zones_count++;

          // Apply purge logic to each zone
          PURGE_MANAGEMENT(1)
          PURGE_MANAGEMENT(2)
          PURGE_MANAGEMENT(3)
          PURGE_MANAGEMENT(4)
          PURGE_MANAGEMENT(5)
          PURGE_MANAGEMENT(6)

          // ============= PASS 3: PRIORITY ANALYSIS AND WAIT STATES =============
          // Determine global priority level: PURGE > HEATING > COOLING > FAN > OFF
          // Zones with lower priority demands enter WAIT state
          
          int global_max_priority = 0; // 0=OFF, 1=FAN, 2=COOLING, 4=HEATING, 6=PURGE
          
          // Calculate priority for each zone
          int z1_priority = 0, z2_priority = 0, z3_priority = 0;
          int z4_priority = 0, z5_priority = 0, z6_priority = 0;
          
          if (z1_state_new == ZONE_PURGE) z1_priority = 6;
          else if (z1_state_new == ZONE_HEATING_STAGE1 || z1_state_new == ZONE_HEATING_STAGE2) z1_priority = 4;
          else if (z1_state_new == ZONE_COOLING_STAGE1 || z1_state_new == ZONE_COOLING_STAGE2) z1_priority = 2;
          else if (z1_state_new == ZONE_FAN_ONLY) z1_priority = 1;
          
          if (z2_state_new == ZONE_PURGE) z2_priority = 6;
          else if (z2_state_new == ZONE_HEATING_STAGE1 || z2_state_new == ZONE_HEATING_STAGE2) z2_priority = 4;
          else if (z2_state_new == ZONE_COOLING_STAGE1 || z2_state_new == ZONE_COOLING_STAGE2) z2_priority = 2;
          else if (z2_state_new == ZONE_FAN_ONLY) z2_priority = 1;
          
          if (z3_state_new == ZONE_PURGE) z3_priority = 6;
          else if (z3_state_new == ZONE_HEATING_STAGE1 || z3_state_new == ZONE_HEATING_STAGE2) z3_priority = 4;
          else if (z3_state_new == ZONE_COOLING_STAGE1 || z3_state_new == ZONE_COOLING_STAGE2) z3_priority = 2;
          else if (z3_state_new == ZONE_FAN_ONLY) z3_priority = 1;
          
          if (z4_state_new == ZONE_PURGE) z4_priority = 6;
          else if (z4_state_new == ZONE_HEATING_STAGE1 || z4_state_new == ZONE_HEATING_STAGE2) z4_priority = 4;
          else if (z4_state_new == ZONE_COOLING_STAGE1 || z4_state_new == ZONE_COOLING_STAGE2) z4_priority = 2;
          else if (z4_state_new == ZONE_FAN_ONLY) z4_priority = 1;
          
          if (z5_state_new == ZONE_PURGE) z5_priority = 6;
          else if (z5_state_new == ZONE_HEATING_STAGE1 || z5_state_new == ZONE_HEATING_STAGE2) z5_priority = 4;
          else if (z5_state_new == ZONE_COOLING_STAGE1 || z5_state_new == ZONE_COOLING_STAGE2) z5_priority = 2;
          else if (z5_state_new == ZONE_FAN_ONLY) z5_priority = 1;
          
          if (z6_state_new == ZONE_PURGE) z6_priority = 6;
          else if (z6_state_new == ZONE_HEATING_STAGE1 || z6_state_new == ZONE_HEATING_STAGE2) z6_priority = 4;
          else if (z6_state_new == ZONE_COOLING_STAGE1 || z6_state_new == ZONE_COOLING_STAGE2) z6_priority = 2;
          else if (z6_state_new == ZONE_FAN_ONLY) z6_priority = 1;
          
          // Find global max priority
          global_max_priority = z1_priority;
          if (z2_priority > global_max_priority) global_max_priority = z2_priority;
          if (z3_priority > global_max_priority) global_max_priority = z3_priority;
          if (z4_priority > global_max_priority) global_max_priority = z4_priority;
          if (z5_priority > global_max_priority) global_max_priority = z5_priority;
          if (z6_priority > global_max_priority) global_max_priority = z6_priority;
          
          // Apply WAIT state to zones with lower priority (but not OFF or ERROR)
          if (z1_priority > 0 && z1_priority < global_max_priority && z1_state_new != ZONE_ERROR) {
            z1_state_new = ZONE_WAIT;
          }
          if (z2_priority > 0 && z2_priority < global_max_priority && z2_state_new != ZONE_ERROR) {
            z2_state_new = ZONE_WAIT;
          }
          if (z3_priority > 0 && z3_priority < global_max_priority && z3_state_new != ZONE_ERROR) {
            z3_state_new = ZONE_WAIT;
          }
          if (z4_priority > 0 && z4_priority < global_max_priority && z4_state_new != ZONE_ERROR) {
            z4_state_new = ZONE_WAIT;
          }
          if (z5_priority > 0 && z5_priority < global_max_priority && z5_state_new != ZONE_ERROR) {
            z5_state_new = ZONE_WAIT;
          }
          if (z6_priority > 0 && z6_priority < global_max_priority && z6_state_new != ZONE_ERROR) {
            z6_state_new = ZONE_WAIT;
          }
          
          // Update state variables if changed (triggers text sensor updates)
          if (z1_state_new != id(z1_state)) {
            id(z1_state) = z1_state_new;
            id(z1_state_text).update();
          }
          if (z2_state_new != id(z2_state)) {
            id(z2_state) = z2_state_new;
            id(z2_state_text).update();
          }
          if (z3_state_new != id(z3_state)) {
            id(z3_state) = z3_state_new;
            id(z3_state_text).update();
          }
          if (z4_state_new != id(z4_state)) {
            id(z4_state) = z4_state_new;
            id(z4_state_text).update();
          }
          if (z5_state_new != id(z5_state)) {
            id(z5_state) = z5_state_new;
            id(z5_state_text).update();
          }
          if (z6_state_new != id(z6_state)) {
            id(z6_state) = z6_state_new;
            id(z6_state_text).update();
          }

          // ============= PASS 4: DAMPER CONTROL =============
          // Damper scripts provide 250ms delay for motor release
          static const char* TAG_DAMPER = "DamperControl";
          
          // Determine if all zones are OFF (special case: all dampers open)
          bool all_zones_off = (global_max_priority == 0);

          // Apply damper control to each zone
          DAMPER_CONTROL(1)
          DAMPER_CONTROL(2)
          DAMPER_CONTROL(3)
          DAMPER_CONTROL(4)
          DAMPER_CONTROL(5)
          DAMPER_CONTROL(6)

          // ============= PASS 5: CENTRAL UNIT OUTPUT CONTROL =============
          // Determines the geothermal unit operating mode based on zone demands
          // Manages: mode selection, stage 2 escalation, purge direction, error handling
          // Only active when geo_auto_mode is true
          static const char* TAG_OUTPUT = "OutputControl";
          
          if (id(geo_auto_mode)) {
            int new_mode = 0;  // Default: Arrêt (index 0)
            
            // --- Error handling: force shutdown on zone error ---
            if (id(zone_error_flag)) {
              new_mode = 0;  // Arrêt
              id(Led_error).turn_on();
              ESP_LOGE(TAG_OUTPUT, "Zone error detected - forcing central unit to Arrêt");
            } else {
              id(Led_error).turn_off();
              
              // --- Determine base mode from global_max_priority ---
              // Priority values: 0=OFF, 1=FAN, 2=COOLING, 4=HEATING, 6=PURGE
              
              if (global_max_priority == 0) {
                // All zones OFF
                new_mode = 0;  // Arrêt
                
              } else if (global_max_priority == 1) {
                // Fan only demand
                new_mode = 1;  // Fan1
                
              } else if (global_max_priority == 2) {
                // Cooling demand - check if any zone needs stage 2
                bool needs_stage2 = false;
                int states[] = {z1_state_new, z2_state_new, z3_state_new, z4_state_new, z5_state_new, z6_state_new};
                for (int i = 0; i < 6; i++) {
                  if (states[i] == ZONE_COOLING_STAGE2) { needs_stage2 = true; break; }
                }
                
                if (needs_stage2) {
                  new_mode = 3;  // Clim Stage 2 (direct thermostat demand)
                } else {
                  new_mode = 2;  // Clim Stage 1
                }
                
                // Update last active mode for purge direction
                id(last_active_mode) = 2;  // cooling
                
              } else if (global_max_priority == 4) {
                // Heating demand - check if any zone needs stage 2
                bool needs_stage2 = false;
                int states[] = {z1_state_new, z2_state_new, z3_state_new, z4_state_new, z5_state_new, z6_state_new};
                for (int i = 0; i < 6; i++) {
                  if (states[i] == ZONE_HEATING_STAGE2) { needs_stage2 = true; break; }
                }
                
                if (needs_stage2) {
                  new_mode = 5;  // Chauffage Stage 2 (direct thermostat demand)
                } else {
                  new_mode = 4;  // Chauffage Stage 1
                }
                
                // Update last active mode for purge direction
                id(last_active_mode) = 1;  // heating
                
              } else if (global_max_priority == 6) {
                // Purge demand - fan only, preserve OB position from last active mode
                if (id(last_active_mode) == 2) {
                  new_mode = 7;  // Purge Clim (G ON, OB ON - same as cooling)
                } else {
                  new_mode = 6;  // Purge Chauffage (G ON, OB OFF - same as heating)
                }
              }
              
              // --- Stage 2 escalation timer ---
              // If in Stage 1 for longer than escalation delay, auto-escalate to Stage 2
              // Only applies when no zone directly requests Stage 2 via thermostat
              if (new_mode == 2 || new_mode == 4) {
                // Currently in Stage 1 - check escalation timer
                if (id(geo_current_mode) != 2 && id(geo_current_mode) != 4) {
                  // Just entered Stage 1 - start timer
                  id(geo_mode_stage1_start_ms) = millis();
                  ESP_LOGI(TAG_OUTPUT, "Stage 1 started - escalation timer armed (%lu ms)", id(geo_stage2_escalation_ms));
                } else if (id(geo_stage2_escalation_ms) > 0) {
                  // Already in Stage 1 - check if escalation delay exceeded
                  unsigned long stage1_elapsed = millis() - id(geo_mode_stage1_start_ms);
                  if (stage1_elapsed >= id(geo_stage2_escalation_ms)) {
                    new_mode = new_mode + 1;  // 2→3 (Clim S2) or 4→5 (Chauffage S2)
                    ESP_LOGW(TAG_OUTPUT, "Stage 2 ESCALATION triggered after %lu ms (threshold: %lu ms)", stage1_elapsed, id(geo_stage2_escalation_ms));
                  }
                }
              } else {
                // Not in Stage 1 - reset escalation timer
                id(geo_mode_stage1_start_ms) = 0;
              }
            }
            
            // --- Apply mode change via select entity ---
            if (new_mode != id(geo_current_mode)) {
              ESP_LOGI(TAG_OUTPUT, "Mode change: %d -> %d (priority: %d)", id(geo_current_mode), new_mode, global_max_priority);
              id(geo_current_mode) = new_mode;
              auto call = id(Geothermie_mode_select).make_call();
              call.set_index(new_mode);
              call.perform();
            }
          }

